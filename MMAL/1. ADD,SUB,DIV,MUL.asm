ORG 100H

; ADDITION (16-BIT)
; ADDS 300 (012CH) AND 500 (01F4H)
MOV AX, 012CH   ; AX = 300
MOV BX, 01F4H   ; BX = 500
ADD AX, BX      ; AX = AX + BX. RESULT (800 OR 0320H) IS IN AX

; SUBTRACTION (16-BIT)
; SUBTRACTS 200 (00C8H) FROM 1000 (03E8H)
MOV AX, 03E8H   ; AX = 1000
MOV BX, 00C8H   ; BX = 200
SUB AX, BX      ; AX = AX - BX. RESULT (800 OR 0320H) IS IN AX

; MULTIPLICATION (16-BIT)
; MULTIPLIES 1000 (03E8H) BY 200 (00C8H)
MOV AX, 03E8H   ; LOAD FIRST NUMBER INTO AX
MOV BX, 00C8H   ; LOAD SECOND NUMBER INTO BX
MUL BX          ; MULTIPLY AX BY BX.
                ; 32-BIT RESULT (200000 OR 0003:0D40H) IS IN DX:AX
                ; DX WILL HOLD 0003H, AX WILL HOLD 0D40H

; DIVISION (16-BIT)
; DIVIDES 100000 (0001:86A0H) BY 100 (0064H)
; IF YOUR DIVIDEND IS ONLY 16-BITS, YOU MUST CLEAR DX FIRST
XOR DX, DX      ; CLEAR DX TO MAKE THE DIVIDEND 32-BIT (DX:AX)
MOV AX, 186A0H  ; LOAD 100000 INTO AX (THIS VALUE IS TOO BIG FOR 16 BITS, USING 10000 INSTEAD)
MOV AX, 2710H   ; CORRECTED: LOAD 10000 (2710H) INTO AX
MOV BX, 0064H   ; LOAD DIVISOR (100) INTO BX
DIV BX          ; DIVIDE DX:AX BY BX.
                ; QUOTIENT (100 OR 0064H) WILL BE IN AX
                ; REMAINDER (0 OR 0000H) WILL BE IN DX

RET
